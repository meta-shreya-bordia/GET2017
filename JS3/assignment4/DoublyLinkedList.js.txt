var linked_list = new DoublyLinked();

(function(){
  document.getElementById("AddAtBeginning").addEventListener("click", function(){performOperation(this);}, false);
  document.getElementById("AddAtEndOfList").addEventListener("click", function(){performOperation(this);}, false);
  document.getElementById("AddAtSpecifiedPosition").addEventListener("click", function(){performOperation(this);}, false);

  document.getElementById("RemoveByElementValue").addEventListener("click", function(){performOperation(this);}, false);
  document.getElementById("RemoveByElementPosition").addEventListener("click", function(){performOperation(this);}, false);

  document.getElementById("SearchByElementValue").addEventListener("click", function(){performOperation(this);}, false);
})();

function performOperation(button_id){
  var element = document.getElementById("element_value").value;
  var place = document.getElementById("element_position").value;

  //call appropriate method
  switch(button_id.id){
    case "AddAtBeginning":
      linked_list.addToPositionInList(element, 0);
      break;

    case "AddAtEndOfList":
      linked_list.addToPositionInList(element, linked_list.lengthOfList);
      break;

    case "AddAtSpecifiedPosition":
      linked_list.addToPositionInList(element, place);
      break;

    case "RemoveByElementValue":
      linked_list.removeElement(element);
      break;

    case "RemoveByElementPosition":
      linked_list.removeElementFromPosition(place);
      break;

    case "SearchByElementValue":
      linked_list.searchAnElement(element);
      break;
  }

  //type error of converting circular list to string
  //document.body.appendChild(document.createElement("p").appendChild(document.createTextNode( JSON.stringify(linked_list) )));
}

/**
Each node in the list contains data element
and pointer to the next node and the node before it
*used for easy insertion and deletion*
*/
function Node(data){
  this.data = data;
  this.previous = null;
  this.next = null;
}

function DoublyLinked(){
  this.lengthOfList = 0;
  this.head = null;
}

//var element_value, position;

DoublyLinked.prototype.checkValidPosition = function(position){
  try{
    alert(isNaN(position));
    if(isNaN(position)==false & position < 0 & position > this.lengthOfList){
      throw new Error('Invalid position value');
    }
  }catch(e){
    alert(e);
    return false;
  }

  return true;
}

DoublyLinked.prototype.addToPositionInList = function(element_value, position){
  var current_node = this.head;
  var iterate = 0;

  //throw exception if position entered is either negative or larger than current list size
  //check valid element value
  if(!element_value | !this.checkValidPosition(position)){
    return;
  }

  //add element to the list
  var node = new Node(element_value);

  //iterate to the specified position
  while(current_node && iterate <= position){
    current_node = current_node.next;
    iterate++;
  }

  // if list is empty or insertion at first position
  if(!current_node || (current_node & !current_node.previous)){
    node.next = this.head;
    this.head = node;
  }else{  //insertion at specific position
    node.next = current_node;
    node.previous = current_node.previous;
    current_node.previous = node;
  }

  this.lengthOfList++;
}

DoublyLinked.prototype.removeElementFromPosition = function(position){
  var current_node = this.head;
  var list_position = 0;

  //throw exception if position entered is either negative or larger than current list size
  if(!this.head || !this.checkValidPosition(position)){
    return;
  }

  //else, iterate to position of element in the list
  while(current_node && list_position < position){
    current_node = current_node.next;
    list_position++;
  }

  //remove first element from the list
  if(current_node!=null & current_node.previous==null & position==0){
    this.head = current_node.next;
    if(current_node.next != null){
      (current_node.next).previous = null;
    }
    this.lengthOfList--;
    return;
  }

  //else, remove element
  current_node.previous.next = current_node.next;
  this.lengthOfList--;
}

DoublyLinked.prototype.removeElement = function(element_value){
  var place = this.searchAnElement(element_value);
  this.removeElementFromPosition(place);
}

DoublyLinked.prototype.searchAnElement = function(element_value){
  var current_node = this.head;
  var list_place = 0;

  if(!element_value){
    return;
  }

  while(current_node && current_node.data != element_value){
    current_node = current_node.next;
    list_place++;
  }

  //if looping stops due to end of list traversal with element not being found
  try{
    if(!current_node){
      throw new Error('Element does not belong to the list');
    }
  }catch(e){
    alert(e);
    return null;
  }

  //return position of element data match
  alert("Element found at: "+list_place);
  return list_place;
}
